{"data":{"post":{"id":"d3e3d09d-e7d5-58f4-995e-b34ab258b2e7","html":"<h2>인증, 인가</h2>\n<h1>인증(Authentication)</h1>\n<ul>\n<li>유저의 identification을 확인하는 절차.</li>\n</ul>\n<h1>인가(Authorization)</h1>\n<ul>\n<li>유저의 request를 실행할 수 있는 권한이 있는 유저인가를 확인하는 절차.</li>\n</ul>\n<h1>작동 방식</h1>\n<ul>\n<li>Access Token => 로그인 했어 라는 Token을 request의 header부분에 붙여서 보냄.</li>\n<li>서버가 Token을 response로 받음</li>\n</ul>\n<h1>유저 비밀번호 암호화 방식</h1>\n<ul>\n<li>\n<p>단방향 해쉬 함수</p>\n<ul>\n<li>애초에 패스워드 보안용으로 설계된 것이 아님.</li>\n<li>동일한 값은 동일하게 해쉬되서 바뀌기 때문에 해쉬값을 역 추적할 수 있다는 단점이 존재함.(rainbow table attack)</li>\n</ul>\n</li>\n<li>보완점으로 나온 것 :  Bcrypt</li>\n</ul>\n<h1>Bcrypt</h1>\n<ul>\n<li>\n<p>salting</p>\n<ul>\n<li>소금을 뿌린다는 것처럼 추가적으로 랜덤 데이터를 더해서 해쉬값을 계산함.</li>\n</ul>\n</li>\n<li>\n<p>key stretching</p>\n<ul>\n<li>단방향 해쉬값을 계산 한 후 그 해쉬값을 또 해쉬하는 형식으로 계속 반복함.</li>\n</ul>\n</li>\n</ul>\n<h1>Web Tokens</h1>\n<ul>\n<li>\n<p>웹상에서 사용할 수 있는 토큰</p>\n<ul>\n<li>웹상인데 제이슨에서 사용할수있는 토큰 : jwt(json web token)</li>\n</ul>\n</li>\n<li>\n<p>웹 토큰을 사용하는 이유?</p>\n<ol>\n<li>속도 문제</li>\n<li>쿠키에 저장해야되는데, 쿠키에 아이디 비밀번호 저장하는 것과, 토큰을 저장하는 것과는 큰 차이가 있음.</li>\n</ol>\n</li>\n<li>웹토큰은 . 로 나뉘어져있는데, 첫번째, 두번째 부분은 코드화로 아무나 복호화 할 수 있음. 암호화가 아니다.</li>\n<li>마지막 세번째 부분 암호화. 서버에서 복호화해서 내가 만든것인지 확인하는 용도이다.</li>\n</ul>\n<h1>데코레이터를 사용하는 이유</h1>\n<ul>\n<li>엔드포인트가 200개가 될 경우 하나하나 코드를 넣어주기도 힘들고, 코드 중복을 없앨 수 있다.</li>\n<li>강제성을 부여할 수 있다. (강제성 부여 : 로그인 상태로 수행되어야 하는 기능들은 로그인 하지 않으면 접근하지 못하도록 한다.)</li>\n<li>\n<p>로그인 데코레이터 구성</p>\n<ol start=\"0\">\n<li>wrapper는 <code class=\"language-text\">self, request, *args, **kwargs</code>를 input</li>\n<li>Front에서 해당 유저의 웹 토큰을 받음.</li>\n<li>토큰이 존재하면 진행, 존재하지 않는다면 status 리턴</li>\n<li>웹 토큰을 decode한 후 그 값으로 해당 유저의 정보에 접근하여 불러옴.</li>\n<li>그 정보를 이용하여 감싸는 함수 실행.</li>\n<li>에러메세지는 try, except를 활용하여 체크.</li>\n</ol>\n</li>\n</ul>\n<br/>\n<h2>git 프로젝트 branch관련</h2>\n<ul>\n<li>branch를 따고나서 작업을 하는 도중, master가 업데이트 되더라도 다시 갱신 할 필요 없이, push해서 merge해주면 된다.</li>\n<li>새로 branch를 따려고 할 때는 pull을 통해서 프로젝트를 업데이트 한 후에 시작한다.</li>\n<li>\n<p>commit은 해당 사항을 진행하는 동안 꾸준히 할 수 있지만, 만약 상대방이 3일동안 1개 commit하고 나는 2주동안 11개의 commit을 한다고 가정 했을때, 상대방의 commit과 나의 commit이 서로 뒤엉켜서 후에 롤백을 하는데 혼선이 될 수 있다.</p>\n<ul>\n<li>이는 commit이 시간순으로 모두 합쳐져 정렬되기 때문에 발생하는 문제이다.</li>\n</ul>\n</li>\n<li>이를 피하기 위해 보통 commit을 여러개 한 뒤, 마지막 push할 때는 squash로 commit을 압축하여 1개로 만들어서 push하게 된다.</li>\n</ul>","fields":{"slug":"/20190430TIL/","prefix":"2019-04-30"},"frontmatter":{"title":"Backend에서 인증, 인가/git 프로젝트 관련","author":"KyleXID","category":"TIL","cover":{"childImageSharp":{"resize":{"src":"/static/django-logo-negative-1d528e2cb5fbc29ad16c74e5d883c371-160fa.png"}}}}},"authornote":{"id":"23c79ddc-82aa-5899-b07b-ef138c6177bc","html":"<p><strong>KyleXID</strong> 파이썬,장고를 기반으로 개발하고있는 백엔드 개발자입니다.<br>\n현재 P2P금융 업체에서 웹개발을 맡고 있습니다.</p>"},"site":{"siteMetadata":{"facebook":{"appId":"2287464308006637"}}}},"pageContext":{"slug":"/20190430TIL/","prev":{"id":"5079586c-e665-5952-a706-5e42a959a02b","fields":{"slug":"/20190429TIL/","prefix":"2019-04-29","source":"posts"},"frontmatter":{"title":"django relative path & python map function","category":"TIL"}},"next":{"id":"d6ef8f15-6ad4-50e4-8dc7-8a675dd35628","fields":{"slug":"/20190501TIL/","prefix":"2019-05-01","source":"posts"},"frontmatter":{"title":"Enum클래스,choices,classmethod 사용/django에서 테이블 이름 변경","category":"TIL"}},"source":"posts"}}