{"data":{"post":{"id":"71cb9580-79cc-5fb4-ac84-ba208e651965","html":"<h1>CodeKata Review</h1>\n<hr>\n<br/>\n **오늘 CodeKata는 문자열을 받아 그 중 중복되지 않은 알파벳으로 이루어진 제일 긴 단어의 길이를 반환하는 함수를 만드는 주제였다.**\n<p> 일단 나의 접근 방법은 일정한 문자 배열을 받을 경우 해당 위치에서 앞부분과 뒷부분으로 나누어 문자를 생성한 뒤 이 부분을 각 변수에 할당하여 각 변수를 비교하는 것으로 접근하였다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">getLengthOfStr</span><span class=\"token punctuation\">(</span>str<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>str<span class=\"token punctuation\">.</span>length <span class=\"token operator\">===</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> str<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> j <span class=\"token operator\">=</span> i<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;</span> str<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>str<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">===</span> str<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token keyword\">let</span> frontstr <span class=\"token operator\">=</span> str<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> j<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n          <span class=\"token keyword\">let</span> behindstr <span class=\"token operator\">=</span> str<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span>j<span class=\"token punctuation\">,</span> str<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  \n          <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>frontstr<span class=\"token punctuation\">.</span>length <span class=\"token operator\">></span> behindstr<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span> frontstr<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>\n\t\t\t<span class=\"token punctuation\">.</span>\n\t\t\t<span class=\"token punctuation\">.</span>\n\t\t\t<span class=\"token punctuation\">.</span></code></pre></div>\n<p><em>앞부분과 뒷부분을</em> <code class=\"language-text\">slice</code><em>로 나누어 앞문자열과 뒷문자열의 길이를 비교하였다.</em><br>\n이 후 앞 문자열이 긴경우 뒷배열의 상황은 생각하지 않아도 되기 때문에 앞 문자열의 길이를 <code class=\"language-text\">return</code>하였다.</p>\n<br/>\n **하지만 이 코드의 문제점은 뒷부분에서 나타났다.**\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>frontstr<span class=\"token punctuation\">.</span>length <span class=\"token operator\">></span> behindstr<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">return</span> frontstr<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>\n          <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> behindstr<span class=\"token punctuation\">.</span>length<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">>=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">--</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n              <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> j <span class=\"token operator\">=</span> i<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> j<span class=\"token operator\">--</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>behindstr<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">===</span> behindstr<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                  <span class=\"token keyword\">let</span> okend2 <span class=\"token operator\">=</span> behindstr<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span>j<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> behindstr<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                  <span class=\"token keyword\">let</span> okend1 <span class=\"token operator\">=</span> behindstr<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> j<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                  <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>okend1<span class=\"token punctuation\">.</span>length <span class=\"token operator\">></span> okend2<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    <span class=\"token keyword\">return</span> okend1<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>\n                    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n                      <span class=\"token keyword\">return</span> okend2<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>\n\t\t\t     <span class=\"token punctuation\">.</span>\n\t\t\t     <span class=\"token punctuation\">.</span>\n\t\t\t     <span class=\"token punctuation\">.</span></code></pre></div>\n<p> 이 코드는 뒷부분이 긴경우인 경우 실행되는 code이다.<br>\n문제점은 뒷부분에서 이렇게 코드를 읽어도 뒷문자열의 배열에 따라 결국 <strong>무한하게 자르고 비교하는 행위</strong>를 계속해야 한다는 것이다.\n결국 접근 방법에 문제가 있다고 생각하여 계속 파트너와 feedback을 주고받다가 결국 시간초과로 coding을 멈추고 다른 작업을 하게되었다.\n<br/>\n<br/></p>\n<h2>Code feedback</h2>\n<hr>\n<br/>\n이후 멘토에게 코드 피드백을 받았다.\n<p><strong>멘토의 모범답안</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">getLengthOfStr</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">let</span> strArr <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">let</span> prevStrArr <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> s<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">let</span> ss <span class=\"token operator\">=</span> s<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">,</span> i<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> j <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span> j <span class=\"token operator\">&lt;</span> strArr<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span> j<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>ss <span class=\"token operator\">===</span> strArr<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                \n                <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>prevStrArr<span class=\"token punctuation\">.</span>length <span class=\"token operator\">&lt;</span> strArr<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n                    prevStrArr <span class=\"token operator\">=</span> strArr<span class=\"token punctuation\">.</span><span class=\"token function\">slice</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token punctuation\">}</span>\n                \n                strArr <span class=\"token operator\">=</span> strArr<span class=\"token punctuation\">.</span><span class=\"token function\">splice</span><span class=\"token punctuation\">(</span>j<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> strArr<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span>\n        \n        strArr<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span>ss<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    \n    <span class=\"token keyword\">return</span> Math<span class=\"token punctuation\">.</span><span class=\"token function\">max</span><span class=\"token punctuation\">(</span>strArr<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">,</span> prevStrArr<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token function\">getLengthOfStr</span><span class=\"token punctuation\">(</span><span class=\"token string\">'taaaytts'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><em>각 문자열을</em> <code class=\"language-text\">slice</code><em>로 잘라 빈 배열에 계속 추가하고 같은 문자열을 만났을때 상황을 정리한 code</em>\n<br/>\n멘토의 코드를 위부터 차근차근 살펴보자.<br>\n먼저 멘토는 빈 배열을 선언하였다.<br>\n<br/></p>\n<p>후에 <code class=\"language-text\">for</code>문을 통하여 각 문자를 <code class=\"language-text\">slice</code>로 자른 뒤 ss에 선언한다. ss를 <code class=\"language-text\">strArr[]</code>의 각 배열과 비교하여 아무것도 일치하는것이 없는 경우 <code class=\"language-text\">strArr</code>배열에 <code class=\"language-text\">push</code>한다.<br>\n<br/></p>\n<p>만약 <code class=\"language-text\">for</code>문을 돌면서 값이 일치하는  경우에는 <code class=\"language-text\">prevStrArr</code>배열의 길이와 <code class=\"language-text\">strArr</code>배열의 길이를 비교하여 <code class=\"language-text\">prevStrArr</code>의 배열의 길이가 작을경우에는 <code class=\"language-text\">strArr</code>의 배열을 <code class=\"language-text\">prevStrArr</code>에 넣어준다.\n<br/>\n<br/></p>\n<p><strong>여기서 <code class=\"language-text\">strArr</code>의 배열을 <code class=\"language-text\">prevStrArr</code>의 배열에 넣어줄 때 <code class=\"language-text\">slice</code>를 쓴 이유는 무엇일까?</strong>  </p>\n<blockquote>\n<p><strong>Array</strong> 는 배열 값 자체가 저장되는 것이 아니라, 그 배열의 참조값이 저장되기 때문이다.<br>\n이를 빠르게 이해하기 위해서 <code class=\"language-text\">let a = [1, 2, 3]</code> 과 <code class=\"language-text\">let b = [1, 2, 3]</code> 이 동일한지 확인하자<br>\n결과는  <strong>false</strong>가 나올것이다.</p>\n</blockquote>\n<p>그렇기 때문에 만약 <code class=\"language-text\">prevStrArr = strArr</code> 처럼 값을 저장하게 되면, 후에 <code class=\"language-text\">strArr</code>의 배열이 바뀔때마다 <code class=\"language-text\">prevStrArr</code>의 값도 동일하게 바뀔것이다.  </p>\n<blockquote>\n<p><em>이는</em> <code class=\"language-text\">prevStrArr</code><em>에 strArr배열 값이  저장된 것이아니라,</em><br>\n<code class=\"language-text\">strArr</code><em>의 참조값을 할당받기  때문이다</em>  </p>\n</blockquote>\n<br/>\n이를 피하기위해 `slice()`형식으로 변수값을 저장해주면 `prevStrArr`에 다른 reference로 배열이 저장되어 독립적인 배열을 갖게된다.\n<br/>\n<p>이후에는 <code class=\"language-text\">strArr</code>이 <code class=\"language-text\">ss</code>와 중복된 값이 마주친 곳에서부터 <code class=\"language-text\">splice</code>하여 함수를 돌려주게 된다.<br>\n그 후 <code class=\"language-text\">Math.max</code>함수를 이용하여 가장 길이가 긴 값을 <code class=\"language-text\">return</code>하게 되면서, 중복되지 않은 알파벳으로 이루어진 제일 긴 단어의 길이를 반환하게 되는 <code class=\"language-text\">function</code>이 완성된다.</p>","fields":{"slug":"/20190417code_review/","prefix":"2019-04-17"},"frontmatter":{"title":"Function to output the longest non-duplicated alphabet","author":"KyleXID","category":"Algorithm","cover":{"childImageSharp":{"resize":{"src":"/static/django-logo-negative-1d528e2cb5fbc29ad16c74e5d883c371-160fa.png"}}}}},"authornote":{"id":"23c79ddc-82aa-5899-b07b-ef138c6177bc","html":"<p><strong>KyleXID</strong> 파이썬,장고를 기반으로 개발하고있는 백엔드 개발자입니다.<br>\n현재 P2P금융 업체에서 웹개발을 맡고 있습니다.</p>"},"site":{"siteMetadata":{"facebook":{"appId":"2287464308006637"}}}},"pageContext":{"slug":"/20190417code_review/","next":{"id":"0e6b6415-e6b6-5de0-84e9-658158f91209","fields":{"slug":"/20190416ubuntu_short_key/","prefix":"2019-04-17","source":"posts"},"frontmatter":{"title":"우분투 단축키/Vim 단축","category":"Ubuntu"}},"source":"posts"}}